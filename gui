--[[
  KILASIK GUI - Advanced Game Control Interface
  This script creates a feature-rich GUI with many commands and features
  
  Usage: Paste the code into your executor and run it
  
  Key System: Requires a valid key to use. Get the key from our Discord server.
  
  Credit: KILASIK
]]
-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Teams = game:GetService("Teams")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local TeleportService = game:GetService("TeleportService")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")
local MarketplaceService = game:GetService("MarketplaceService")
local VirtualUser = game:GetService("VirtualUser")
local NetworkClient = game:GetService("NetworkClient")
local GuiService = game:GetService("GuiService")
-- Key System
local KEY_CODE = "KILASIK2025" -- Key code
local DISCORD_LINK = "https://discord.gg/PHxN8nadgk" -- Discord server link
local keyVerified = false
-- Basic variables
local player = Players.LocalPlayer
local mouse = player:GetMouse()
local camera = Workspace.CurrentCamera
local guiCreated = false
local guiVisible = false
local minimized = false
local miniSize = false
local activeTab = "Main"
local favoriteCommands = {}
local isResizing = false
local minSize = Vector2.new(400, 300)
local maxSize = Vector2.new(800, 600)
-- Keybind settings
local keybindSettings = {
    ESP = "E",
    Aimbot = "B",
    Fly = "F",
    Noclip = "N",
    ClickTP = "LeftControl",
    Reset = "R",
    WallHack = "V",
    InfiniteJump = "J"
}
-- Animation settings
local animationTracks = {}
local animationIds = {
    zombie = "rbxassetid://616158929",
    ninja = "rbxassetid://656117400",
    robot = "rbxassetid://3716636869",
    dab = "rbxassetid://3303391864",
    floss = "rbxassetid://5917459365",
    groove = "rbxassetid://3303391864",
    lay = "rbxassetid://3152378852",
    sit = "rbxassetid://2506281703",
    superhero = "rbxassetid://616088887",
    spin = "rbxassetid://188632011"
}
-- Speed and character control
local walkSpeed = 16
local jumpPower = 50
local infiniteJump = false
local noclip = false
local flying = false
local flySpeed = 2
local xray = false
local esp = {
    enabled = false,
    boxes = true,
    names = true,
    distances = true,
    teamCheck = true,
    teamColor = true,
    tracers = false,
    chams = false
}
local aimbotSettings = {
    enabled = false,
    teamCheck = true,
    visibilityCheck = true,
    aimPart = "Head",
    sensitivity = 0.5,
    fovSize = 100,
    showFOV = true,
    toggleKey = "RightMouse",
    wallbangEnabled = false
}
local aimbotTarget = nil
local selectedPlayers = {}
local selectedParts = {}
-- GUI Colors
local colors = {
    background = Color3.fromRGB(25, 25, 30),
    header = Color3.fromRGB(35, 35, 40),
    button = Color3.fromRGB(45, 45, 55),
    buttonHover = Color3.fromRGB(55, 55, 65),
    buttonSelected = Color3.fromRGB(65, 105, 225),
    text = Color3.fromRGB(240, 240, 240),
    highlight = Color3.fromRGB(65, 105, 225),
    warning = Color3.fromRGB(200, 60, 60),
    success = Color3.fromRGB(60, 180, 75),
    neutralLight = Color3.fromRGB(70, 70, 85),
    neutralDark = Color3.fromRGB(40, 40, 50),
    shadow = Color3.fromRGB(15, 15, 20),
    categoryBG = Color3.fromRGB(30, 30, 35),
    favorite = Color3.fromRGB(255, 215, 0)
}
-- Categories
local categories = {
    "Favorites",
    "Main",
    "Character",
    "Combat",
    "ESP",
    "Teleport",
    "Players",
    "Animations",
    "Vision",
    "Utility",
    "Fun",
    "Visuals",
    "Settings"
}
-- Function Declarations
function setStatus(text)
    -- Set status bar text (will be implemented with GUI)
end
function setWalkSpeed(speed)
    if not player.Character or not player.Character:FindFirstChild("Humanoid") then return end
    player.Character.Humanoid.WalkSpeed = speed
    walkSpeed = speed
    setStatus("Walk speed set to " .. speed)
end
function setJumpPower(power)
    if not player.Character or not player.Character:FindFirstChild("Humanoid") then return end
    player.Character.Humanoid.JumpPower = power
    jumpPower = power
    setStatus("Jump power set to " .. power)
end
function toggleInfiniteJump()
    infiniteJump = not infiniteJump
    
    if infiniteJump then
        setStatus("Infinite jump enabled")
    else
        setStatus("Infinite jump disabled")
    end
end
function resetCharacter()
    if player.Character then
        player.Character:BreakJoints() -- Kill character to reset
        setStatus("Character reset")
    else
        setStatus("No character to reset")
    end
end
function toggleNoclip()
    noclip = not noclip
    
    if noclip then
        if getgenv().NoclipLoop then
            getgenv().NoclipLoop:Disconnect()
        end
        
        getgenv().NoclipLoop = RunService.Stepped:Connect(function()
            if not noclip then
                getgenv().NoclipLoop:Disconnect()
                getgenv().NoclipLoop = nil
                
                if player.Character then
                    for _, part in pairs(player.Character:GetDescendants()) do
                        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                            part.CanCollide = true
                        end
                    end
                end
                return
            end
            
            if player.Character then
                for _, part in pairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then
                        part.CanCollide = false
                    end
                end
            end
        end)
        setStatus("Noclip enabled")
    else
        if getgenv().NoclipLoop then
            getgenv().NoclipLoop:Disconnect()
            getgenv().NoclipLoop = nil
        end
        
        if player.Character then
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = true
                end
            end
        end
        setStatus("Noclip disabled")
    end
end
function toggleFly()
    flying = not flying
    
    if flying then
        -- Start fly code
        local flyPart = Instance.new("BodyVelocity")
        flyPart.Velocity = Vector3.new(0, 0, 0)
        flyPart.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        flyPart.Name = "FlyPart"
        
        -- Character movement
        local controls = {
            f = false,
            b = false,
            l = false,
            r = false,
            q = false,
            e = false
        }
        
        local controlsChanged = {}
        
        -- Keyboard controls
        controlsChanged.w = UserInputService.InputBegan:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.W then controls.f = true end
            if input.KeyCode == Enum.KeyCode.S then controls.b = true end
            if input.KeyCode == Enum.KeyCode.A then controls.l = true end
            if input.KeyCode == Enum.KeyCode.D then controls.r = true end
            if input.KeyCode == Enum.KeyCode.Q then controls.q = true end
            if input.KeyCode == Enum.KeyCode.E then controls.e = true end
        end)
        
        controlsChanged.s = UserInputService.InputEnded:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.W then controls.f = false end
            if input.KeyCode == Enum.KeyCode.S then controls.b = false end
            if input.KeyCode == Enum.KeyCode.A then controls.l = false end
            if input.KeyCode == Enum.KeyCode.D then controls.r = false end
            if input.KeyCode == Enum.KeyCode.Q then controls.q = false end
            if input.KeyCode == Enum.KeyCode.E then controls.e = false end
        end)
        
        local function fly()
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
            
            local rootPart = player.Character.HumanoidRootPart
            local flyPartInstance = rootPart:FindFirstChild("FlyPart") or flyPart:Clone()
            flyPartInstance.Parent = rootPart
            
            local flyLoop
            flyLoop = RunService.Heartbeat:Connect(function()
                if not flying then 
                    flyLoop:Disconnect()
                    if flyPartInstance and flyPartInstance.Parent then
                        flyPartInstance:Destroy()
                    end
                    player.Character.Humanoid.PlatformStand = false
                    return 
                end
                
                player.Character.Humanoid.PlatformStand = true
                
                local direction = Vector3.new(0, 0, 0)
                
                -- Move based on camera direction
                local lookVector = camera.CFrame.LookVector
                local rightVector = camera.CFrame.RightVector
                
                if controls.f then
                    direction = direction + lookVector
                end
                if controls.b then
                    direction = direction - lookVector
                end
                if controls.r then
                    direction = direction + rightVector
                end
                if controls.l then
                    direction = direction - rightVector
                end
                if controls.q then
                    direction = direction + Vector3.new(0, 1, 0)
                end
                if controls.e then
                    direction = direction + Vector3.new(0, -1, 0)
                end
                
                if direction.Magnitude > 0 then
                    direction = direction.Unit
                end
                
                flyPartInstance.Velocity = direction * flySpeed * 50
            end)
        end
        
        fly()
        setStatus("Fly mode enabled - Use WASDQE to move")
    else
        -- Disable fly mode
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local flyPartInstance = player.Character.HumanoidRootPart:FindFirstChild("FlyPart")
            if flyPartInstance then
                flyPartInstance:Destroy()
            end
        end
        
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.PlatformStand = false
        end
        
        setStatus("Fly mode disabled")
    end
end
function toggleXRay()
    xray = not xray
    
    if xray then
        -- Make walls transparent
        for _, part in ipairs(Workspace:GetDescendants()) do
            if part:IsA("BasePart") and not part:IsDescendantOf(player.Character) and part.Transparency < 0.8 and not part:IsA("Terrain") then
                if not part:FindFirstChild("OriginalTransparency") then
                    local originalValue = Instance.new("NumberValue")
                    originalValue.Name = "OriginalTransparency"
                    originalValue.Value = part.Transparency
                    originalValue.Parent = part
                end
                part.Transparency = 0.8
            end
        end
        setStatus("X-Ray enabled")
    else
        -- Restore wall transparency
        for _, part in ipairs(Workspace:GetDescendants()) do
            if part:IsA("BasePart") and part:FindFirstChild("OriginalTransparency") then
                part.Transparency = part.OriginalTransparency.Value
                part.OriginalTransparency:Destroy()
            end
        end
        setStatus("X-Ray disabled")
    end
end
function cleanupESP(targetPlayer)
    if targetPlayer.Character then
        -- Clean up ESP container
        local espContainer = targetPlayer.Character:FindFirstChild("KILASIK_ESP_Container")
        if espContainer then
            espContainer:Destroy()
        end
        
        -- Clean up Chams
        local chamsESP = targetPlayer.Character:FindFirstChild("KILASIK_Chams")
        if chamsESP then
            chamsESP:Destroy()
        end
    end
end
function updatePlayerESP(targetPlayer, isFriendly)
    -- Determine color
    local espColor = isFriendly and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    
    -- Use team color
    if esp.teamColor and targetPlayer.Team then
        espColor = targetPlayer.TeamColor.Color
    end
    
    -- Create or get ESP container
    local espContainer = targetPlayer.Character:FindFirstChild("KILASIK_ESP_Container")
    if not espContainer then
        espContainer = Instance.new("Folder")
        espContainer.Name = "KILASIK_ESP_Container"
        espContainer.Parent = targetPlayer.Character
    end
    
    -- Box ESP
    if esp.boxes then
        local boxESP = espContainer:FindFirstChild("BoxESP")
        if not boxESP then
            boxESP = Instance.new("BoxHandleAdornment")
            boxESP.Name = "BoxESP"
            boxESP.Adornee = targetPlayer.Character
            boxESP.AlwaysOnTop = true
            boxESP.ZIndex = 10
            boxESP.Size = targetPlayer.Character:GetExtentsSize()
            boxESP.Color3 = espColor
            boxESP.Transparency = 0.7
            boxESP.Parent = espContainer
        else
            boxESP.Size = targetPlayer.Character:GetExtentsSize()
            boxESP.Color3 = espColor
        end
    else
        local boxESP = espContainer:FindFirstChild("BoxESP")
        if boxESP then boxESP:Destroy() end
    end
    
    -- Name ESP
    if esp.names then
        local nameESP = espContainer:FindFirstChild("NameESP")
        if not nameESP then
            nameESP = Instance.new("BillboardGui")
            nameESP.Name = "NameESP"
            nameESP.AlwaysOnTop = true
            nameESP.Size = UDim2.new(0, 200, 0, 50)
            nameESP.StudsOffset = Vector3.new(0, 3, 0)
            nameESP.Adornee = targetPlayer.Character.Head
            
            local nameLabel = Instance.new("TextLabel")
            nameLabel.Name = "NameLabel"
            nameLabel.BackgroundTransparency = 1
            nameLabel.Size = UDim2.new(1, 0, 1, 0)
            nameLabel.Font = Enum.Font.SourceSansBold
            nameLabel.TextSize = 20
            nameLabel.TextColor3 = espColor
            nameLabel.TextStrokeTransparency = 0.5
            nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
            nameLabel.Parent = nameESP
            
            nameESP.Parent = espContainer
        end
        
        local nameLabel = nameESP.NameLabel
        local distance = (targetPlayer.Character.Head.Position - player.Character.Head.Position).Magnitude
        nameLabel.Text = targetPlayer.Name .. " [" .. math.floor(distance) .. "m]"
        nameLabel.TextColor3 = espColor
    else
        local nameESP = espContainer:FindFirstChild("NameESP")
        if nameESP then nameESP:Destroy() end
    end
    
    -- Tracer ESP
    if esp.tracers then
        local tracerESP = espContainer:FindFirstChild("TracerESP")
        if not tracerESP then
            tracerESP = Instance.new("Beam")
            tracerESP.Name = "TracerESP"
            tracerESP.Width0 = 0.1
            tracerESP.Width1 = 0.1
            tracerESP.Color = ColorSequence.new(espColor)
            tracerESP.FaceCamera = true
            
            -- Start and end points
            local a0 = Instance.new("Attachment")
            a0.Position = Vector3.new(0, -2.5, 0) -- Bottom of character
            a0.Parent = targetPlayer.Character.HumanoidRootPart
            
            local a1 = Instance.new("Attachment")
            a1.Position = Vector3.new(0, -2.5, 0) -- Camera center
            a1.Parent = workspace.CurrentCamera
            
            tracerESP.Attachment0 = a0
            tracerESP.Attachment1 = a1
            tracerESP.Parent = espContainer
        else
            tracerESP.Color = ColorSequence.new(espColor)
        end
    else
        local tracerESP = espContainer:FindFirstChild("TracerESP")
        if tracerESP then 
            if tracerESP.Attachment0 then tracerESP.Attachment0:Destroy() end
            if tracerESP.Attachment1 then tracerESP.Attachment1:Destroy() end
            tracerESP:Destroy() 
        end
    end
    
    -- Chams ESP
    if esp.chams then
        local chamsESP = targetPlayer.Character:FindFirstChild("KILASIK_Chams")
        if not chamsESP then
            chamsESP = Instance.new("Highlight")
            chamsESP.Name = "KILASIK_Chams"
            chamsESP.FillColor = espColor
            chamsESP.OutlineColor = espColor
            chamsESP.FillTransparency = 0.5
            chamsESP.OutlineTransparency = 0
            chamsESP.Parent = targetPlayer.Character
        else
            chamsESP.FillColor = espColor
            chamsESP.OutlineColor = espColor
        end
    else
        local chamsESP = targetPlayer.Character:FindFirstChild("KILASIK_Chams")
        if chamsESP then chamsESP:Destroy() end
    end
end
function toggleESP()
    esp.enabled = not esp.enabled
    
    if esp.enabled then
        -- Start ESP
        getgenv().ESPUpdateLoop = RunService.RenderStepped:Connect(function()
            if not esp.enabled then 
                getgenv().ESPUpdateLoop:Disconnect()
                getgenv().ESPUpdateLoop = nil
                
                -- Clean up ESP elements
                for _, plyr in ipairs(Players:GetPlayers()) do
                    cleanupESP(plyr)
                end
                return
            end
            
            -- Update ESP for all players
            for _, otherPlayer in ipairs(Players:GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character and 
                   otherPlayer.Character:FindFirstChild("HumanoidRootPart") and 
                   otherPlayer.Character:FindFirstChild("Humanoid") and
                   otherPlayer.Character:FindFirstChild("Head") then
                    
                    -- Check team status
                    local isFriendly = false
                    if esp.teamCheck and player.Team and otherPlayer.Team then
                        isFriendly = player.Team == otherPlayer.Team
                    end
                    
                    -- If not friendly or team check is off
                    if not esp.teamCheck or not isFriendly then
                        -- Update ESP elements
                        updatePlayerESP(otherPlayer, isFriendly)
                    else
                        -- Clean up friendly player's ESP
                        cleanupESP(otherPlayer)
                    end
                end
            end
        end)
        
        setStatus("ESP enabled")
    else
        -- Disable ESP, clean up elements
        if getgenv().ESPUpdateLoop then
            getgenv().ESPUpdateLoop:Disconnect()
            getgenv().ESPUpdateLoop = nil
        end
        
        for _, plyr in ipairs(Players:GetPlayers()) do
            cleanupESP(plyr)
        end
        
        setStatus("ESP disabled")
    end
end
function toggleESPOption(option)
    if option == "boxes" then
        esp.boxes = not esp.boxes
        setStatus("ESP Boxes: " .. (esp.boxes and "Enabled" or "Disabled"))
    elseif option == "names" then
        esp.names = not esp.names
        setStatus("ESP Names: " .. (esp.names and "Enabled" or "Disabled"))
    elseif option == "tracers" then
        esp.tracers = not esp.tracers
        setStatus("ESP Tracers: " .. (esp.tracers and "Enabled" or "Disabled"))
    elseif option == "teamCheck" then
        esp.teamCheck = not esp.teamCheck
        setStatus("ESP Team Check: " .. (esp.teamCheck and "Enabled" or "Disabled"))
    elseif option == "teamColor" then
        esp.teamColor = not esp.teamColor
        setStatus("ESP Team Color: " .. (esp.teamColor and "Enabled" or "Disabled"))
    elseif option == "chams" then
        esp.chams = not esp.chams
        setStatus("ESP Chams: " .. (esp.chams and "Enabled" or "Disabled"))
        
        -- Apply or remove chams
        if esp.enabled then
            for _, plyr in ipairs(Players:GetPlayers()) do
                cleanupESP(plyr)
            end
        end
    end
end
function isTargetVisible(character, partName)
    if not character or not character:FindFirstChild(partName) or not player.Character or not player.Character:FindFirstChild("Head") then
        return false
    end
    
    local targetPart = character[partName]
    local origin = player.Character.Head.Position
    local direction = (targetPart.Position - origin).Unit
    local distance = (targetPart.Position - origin).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(origin, direction * distance, raycastParams)
    
    if raycastResult then
        return raycastResult.Instance:IsDescendantOf(character)
    end
    
    return true
end
function setAimbotFOV(size)
    aimbotSettings.fovSize = size
    setStatus("Aimbot FOV size set to: " .. size)
    
    -- Update FOV circle if it exists
    if aimbotSettings.enabled and aimbotSettings.showFOV then
        local fovcircle = Drawing.new("Circle")
        fovcircle.Visible = true
        fovcircle.Radius = size
        fovcircle.Thickness = 1
        fovcircle.Transparency = 1
        fovcircle.Color = Color3.fromRGB(255, 255, 255)
        fovcircle.Position = camera.ViewportSize / 2
        
        -- Store it in the settings
        if getgenv().FOVCircle then
            getgenv().FOVCircle:Remove()
        end
        getgenv().FOVCircle = fovcircle
    end
end
function toggleWallbang()
    aimbotSettings.wallbangEnabled = not aimbotSettings.wallbangEnabled
    setStatus("Wallbang: " .. (aimbotSettings.wallbangEnabled and "Enabled" or "Disabled"))
end
function toggleAimbot()
    aimbotSettings.enabled = not aimbotSettings.enabled
    
    if aimbotSettings.enabled then
        -- Create FOV circle if showing
        if aimbotSettings.showFOV then
            local fovcircle = Drawing.new("Circle")
            fovcircle.Visible = true
            fovcircle.Radius = aimbotSettings.fovSize
            fovcircle.Thickness = 1
            fovcircle.Transparency = 1
            fovcircle.Color = Color3.fromRGB(255, 255, 255)
            fovcircle.Position = camera.ViewportSize / 2
            
            -- Store it for later updates
            if getgenv().FOVCircle then
                getgenv().FOVCircle:Remove()
            end
            getgenv().FOVCircle = fovcircle
        end
        
        -- Create aimbot update loop
        if not getgenv().AimbotUpdateLoop then
            getgenv().AimbotUpdateLoop = RunService.RenderStepped:Connect(function()
                if not aimbotSettings.enabled then
                    getgenv().AimbotUpdateLoop:Disconnect()
                    getgenv().AimbotUpdateLoop = nil
                    
                    -- Remove FOV circle
                    if getgenv().FOVCircle then
                        getgenv().FOVCircle:Remove()
                        getgenv().FOVCircle = nil
                    end
                    return
                end
                
                -- Update FOV circle position
                if getgenv().FOVCircle then
                    getgenv().FOVCircle.Position = camera.ViewportSize / 2
                end
                
                -- Check for right mouse button (or whatever key is set)
                local isKeyDown = false
                if aimbotSettings.toggleKey == "RightMouse" then
                    isKeyDown = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
                else
                    isKeyDown = UserInputService:IsKeyDown(Enum.KeyCode[aimbotSettings.toggleKey])
                end
                
                if not isKeyDown then
                    aimbotTarget = nil
                    return
                end
                
                -- Find closest player within FOV
                local closestPlayer = nil
                local closestDistance = math.huge
                local screenCenter = camera.ViewportSize / 2
                
                for _, otherPlayer in ipairs(Players:GetPlayers()) do
                    if otherPlayer ~= player and otherPlayer.Character and 
                       otherPlayer.Character:FindFirstChild("Humanoid") and 
                       otherPlayer.Character.Humanoid.Health > 0 and
                       otherPlayer.Character:FindFirstChild(aimbotSettings.aimPart) then
                        
                        -- Check team if team check enabled
                        if aimbotSettings.teamCheck and player.Team and otherPlayer.Team and player.Team == otherPlayer.Team then
                            continue
                        end
                        
                        -- Check if target is visible if visibility check enabled
                        if aimbotSettings.visibilityCheck and not isTargetVisible(otherPlayer.Character, aimbotSettings.aimPart) then
                            continue
                        end
                        
                        -- Check if target is within FOV
                        local targetPart = otherPlayer.Character[aimbotSettings.aimPart]
                        local screenPoint = camera:WorldToScreenPoint(targetPart.Position)
                        
                        if screenPoint.Z > 0 then
                            local screenDistance = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude
                            
                            if screenDistance <= aimbotSettings.fovSize then
                                if screenDistance < closestDistance then
                                    closestDistance = screenDistance
                                    closestPlayer = otherPlayer
                                end
                            end
                        end
                    end
                end
                
                -- Aim at the closest player
                if closestPlayer then
                    aimbotTarget = closestPlayer
                    local targetPart = closestPlayer.Character[aimbotSettings.aimPart]
                    
                    -- Calculate aim point, adding a bit of smoothing
                    local targetPos = targetPart.Position
                    local aimPos = camera.CFrame.Position + (targetPos - camera.CFrame.Position).Unit * 1000
                    
                    -- Apply smoothing
                    local currentAim = camera.CFrame.LookVector
                    local targetAim = (targetPos - camera.CFrame.Position).Unit
                    local smoothedAim = currentAim:Lerp(targetAim, aimbotSettings.sensitivity)
                    
                    -- Set camera to look at target
                    camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + smoothedAim * 1000)
                else
                    aimbotTarget = nil
                end
            end)
        end
        
        setStatus("Aimbot enabled - Right click to activate")
    else
        aimbotTarget = nil
        
        -- Cleanup
        if getgenv().AimbotUpdateLoop then
            getgenv().AimbotUpdateLoop:Disconnect()
            getgenv().AimbotUpdateLoop = nil
        end
        
        if getgenv().FOVCircle then
            getgenv().FOVCircle:Remove()
            getgenv().FOVCircle = nil
        end
        
        setStatus("Aimbot disabled")
    end
end
function showAimbotSettings()
    -- This would create a settings menu, but for now just toggle options
    aimbotSettings.teamCheck = not aimbotSettings.teamCheck
    setStatus("Aimbot Team Check: " .. (aimbotSettings.teamCheck and "Enabled" or "Disabled"))
end
function toggleClickTP()
    local clickTPEnabled = not getgenv().ClickTPEnabled
    
    if clickTPEnabled then
        if not getgenv().ClickTPConnection then
            getgenv().ClickTPConnection = mouse.Button1Down:Connect(function()
                if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        player.Character.HumanoidRootPart.CFrame = CFrame.new(mouse.Hit.Position + Vector3.new(0, 5, 0))
                    end
                end
            end)
        end
        setStatus("Click Teleport enabled - Ctrl+Click to teleport")
    else
        if getgenv().ClickTPConnection then
            getgenv().ClickTPConnection:Disconnect()
            getgenv().ClickTPConnection = nil
        end
        setStatus("Click Teleport disabled")
    end
    
    getgenv().ClickTPEnabled = clickTPEnabled
end
function teleportToMouse()
    local mousePos = mouse.Hit.Position
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(mousePos + Vector3.new(0, 5, 0))
        setStatus("Teleported to mouse position")
    else
        setStatus("Teleport failed: Character not found")
    end
end
function getPlayerFromName(name)
    name = name:lower()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Name:lower():find(name) then
            return plr
        end
    end
    return nil
end
function createPlayerSelector(title, callback)
    -- Create player selection menu
    local selectorFrame = Instance.new("Frame")
    selectorFrame.Name = "PlayerSelector"
    selectorFrame.Size = UDim2.new(0, 250, 0, 300)
    selectorFrame.Position = UDim2.new(0.5, -125, 0.5, -150)
    selectorFrame.BackgroundColor3 = colors.background
    selectorFrame.BorderSizePixel = 0
    selectorFrame.ZIndex = 100
    selectorFrame.Parent = mainGUI
    
    local selectorCorner = Instance.new("UICorner")
    selectorCorner.CornerRadius = UDim.new(0, 8)
    selectorCorner.Parent = selectorFrame
    
    -- Title
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0, 30)
    titleLabel.BackgroundColor3 = colors.header
    titleLabel.BorderSizePixel = 0
    titleLabel.Text = title or "Select Player"
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextSize = 16
    titleLabel.TextColor3 = colors.text
    titleLabel.ZIndex = 101
    titleLabel.Parent = selectorFrame
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = titleLabel
    
    local titleBottom = Instance.new("Frame")
    titleBottom.Size = UDim2.new(1, 0, 0, 10)
    titleBottom.Position = UDim2.new(0, 0, 1, -10)
    titleBottom.BackgroundColor3 = colors.header
    titleBottom.BorderSizePixel = 0
    titleBottom.ZIndex = 100
    titleBottom.Parent = titleLabel
    
    -- Close button
    local closeBtn = Instance.new("TextButton")
    closeBtn.Size = UDim2.new(0, 24, 0, 24)
    closeBtn.Position = UDim2.new(1, -27, 0, 3)
    closeBtn.BackgroundColor3 = colors.warning
    closeBtn.Text = "X"
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 14
    closeBtn.TextColor3 = colors.text
    closeBtn.ZIndex = 102
    closeBtn.BorderSizePixel = 0
    closeBtn.Parent = titleLabel
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 4)
    closeCorner.Parent = closeBtn
    
    -- Player list
    local playerList = Instance.new("ScrollingFrame")
    playerList.Name = "PlayerList"
    playerList.Size = UDim2.new(1, -20, 1, -40)
    playerList.Position = UDim2.new(0, 10, 0, 35)
    playerList.BackgroundTransparency = 1
    playerList.BorderSizePixel = 0
    playerList.ScrollBarThickness = 6
    playerList.ZIndex = 101
    playerList.ScrollBarImageColor3 = colors.neutralLight
    playerList.Parent = selectorFrame
    
    local playerListLayout = Instance.new("UIListLayout")
    playerListLayout.Padding = UDim.new(0, 5)
    playerListLayout.Parent = playerList
    
    -- Add players
    local function refreshPlayers()
        -- Clear existing buttons
        for _, child in pairs(playerList:GetChildren()) do
            if child:IsA("TextButton") then
                child:Destroy()
            end
        end
        
        -- Add new buttons
        local yOffset = 0
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= player then -- Don't list ourselves
                local playerButton = Instance.new("TextButton")
                playerButton.Size = UDim2.new(1, -5, 0, 40)
                playerButton.BackgroundColor3 = colors.button
                playerButton.Text = ""
                playerButton.BorderSizePixel = 0
                playerButton.ZIndex = 101
                playerButton.Parent = playerList
                
                local buttonCorner = Instance.new("UICorner")
                buttonCorner.CornerRadius = UDim.new(0, 6)
                buttonCorner.Parent = playerButton
                
                local nameLabel = Instance.new("TextLabel")
                nameLabel.Size = UDim2.new(1, -10, 1, 0)
                nameLabel.Position = UDim2.new(0, 10, 0, 0)
                nameLabel.BackgroundTransparency = 1
                nameLabel.Text = plr.Name
                nameLabel.Font = Enum.Font.GothamSemibold
                nameLabel.TextSize = 14
                nameLabel.TextColor3 = colors.text
                nameLabel.TextXAlignment = Enum.TextXAlignment.Left
                nameLabel.ZIndex = 102
                nameLabel.Parent = playerButton
                
                -- Show team color if available
                if plr.Team then
                    nameLabel.TextColor3 = plr.TeamColor.Color
                end
                
                -- Button click
                playerButton.MouseButton1Click:Connect(function()
                    -- Send selected player to callback
                    if callback then
                        callback(plr)
                    end
                    
                    -- Close menu
                    selectorFrame:Destroy()
                end)
                
                yOffset = yOffset + 45
            end
        end
        
        -- Adjust canvas size
        playerList.CanvasSize = UDim2.new(0, 0, 0, yOffset)
    end
    
    -- Close button
    closeBtn.MouseButton1Click:Connect(function()
        selectorFrame:Destroy()
    end)
    
    -- List players
    refreshPlayers()
    
    -- Update list on player join/leave
    Players.PlayerAdded:Connect(refreshPlayers)
    Players.PlayerRemoving:Connect(refreshPlayers)
    
    return selectorFrame
end
function teleportToPlayer(targetName)
    -- If name provided directly
    if targetName and targetName ~= "" then
        local targetPlayer = getPlayerFromName(targetName)
        
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and
           player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 2)
            setStatus("Teleported to " .. targetPlayer.Name)
        else
            setStatus("Player not found or unreachable")
        end
        return
    end
    
    -- If no name provided, show player selector
    createPlayerSelector("Select Player to Teleport", function(targetPlayer)
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and
           player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 2)
            setStatus("Teleported to " .. targetPlayer.Name)
        else
            setStatus("Player not found or unreachable")
        end
    end)
end
function rejoinServer()
    setStatus("Rejoining server...")
    TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
end
function removeFog()
    Lighting.FogStart = 100000
    Lighting.FogEnd = 100000
    setStatus("Fog removed")
end
function enableFullBright()
    local oldAmbient = Lighting.Ambient
    Lighting.Ambient = Color3.fromRGB(255, 255, 255)
    Lighting.Brightness = 2
    Lighting.ClockTime = 14
    Lighting.FogEnd = 100000
    Lighting.GlobalShadows = false
    Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
    
    setStatus("Full brightness enabled")
end
function makeInvisible()
    if player.Character then
        for _, part in pairs(player.Character:GetDescendants()) do
            if part:IsA("BasePart") or part:IsA("Decal") and part.Name ~= "HumanoidRootPart" then
                part.Transparency = 1
            end
        end
        setStatus("Invisibility enabled (semi-invisible)")
    end
end
function removeMeshes()
    if player.Character then
        for _, part in pairs(player.Character:GetDescendants()) do
            if part:IsA("SpecialMesh") or part:IsA("Mesh") or part:IsA("MeshPart") then
                part:Destroy()
            end
        end
        setStatus("Meshes removed")
    end
end
function toggleKillAura()
    local killAuraEnabled = not (getgenv().KillAuraConnection ~= nil)
    
    if killAuraEnabled then
        local range = 15 -- Hit range
        
        -- KillAura loop
        getgenv().KillAuraConnection = RunService.Heartbeat:Connect(function()
            for _, otherPlayer in ipairs(Players:GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character and player.Character and
                   otherPlayer.Character:FindFirstChild("Humanoid") and
                   otherPlayer.Character.Humanoid.Health > 0 and
                   otherPlayer.Character:FindFirstChild("HumanoidRootPart") and
                   player.Character:FindFirstChild("HumanoidRootPart") then
                    
                    -- Check team if applicable
                    if player.Team and otherPlayer.Team and player.Team == otherPlayer.Team then
                        continue
                    end
                    
                    local distance = (otherPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                    
                    if distance <= range then
                        -- Find weapon and hit
                        for _, tool in pairs(player.Character:GetChildren()) do
                            if tool:IsA("Tool") and (tool:FindFirstChild("Handle") or tool:FindFirstChild("Blade")) then
                                -- Try different methods to hit
                                
                                -- Method 1: Direct hit
                                if tool.Name:lower():find("sword") or tool.Name:lower():find("knife") then
                                    tool:Activate()
                                    -- Target the hit
                                    local handlePart = tool:FindFirstChild("Handle") or tool:FindFirstChild("Blade")
                                    if handlePart then
                                        handlePart.CFrame = otherPlayer.Character.HumanoidRootPart.CFrame
                                    end
                                end
                                
                                -- Method 2: Remote event
                                for _, event in pairs(tool:GetDescendants()) do
                                    if event:IsA("RemoteEvent") and (event.Name:lower():find("hit") or event.Name:lower():find("damage")) then
                                        event:FireServer(otherPlayer.Character.HumanoidRootPart)
                                    end
                                end
                                
                                -- Method 3: Try game-specific events
                                for _, event in pairs(ReplicatedStorage:GetDescendants()) do
                                    if event:IsA("RemoteEvent") and (event.Name:lower():find("damage") or event.Name:lower():find("hit")) then
                                        event:FireServer(otherPlayer.Character.HumanoidRootPart)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
        
        setStatus("KillAura enabled - 15 stud range")
    else
        if getgenv().KillAuraConnection then
            getgenv().KillAuraConnection:Disconnect()
            getgenv().KillAuraConnection = nil
        end
        
        setStatus("KillAura disabled")
    end
end
function giveInfiniteAmmo()
    local gunHook
    gunHook = hookmetamethod(game, "__namecall", function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        
        if method == "FireServer" and self.Name:lower():find("ammo") or self.Name:lower():find("bullet") then
            -- Ammo count hook
            return
        end
        
        return gunHook(self, ...)
    end)
    
    setStatus("Infinite ammo activated (may not work in all games)")
end
function attemptGodMode()
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        -- Method 1: Clone Humanoid
        local humanoid = player.Character.Humanoid
        local cloneHum = humanoid:Clone()
        humanoid.Name = "1"
        cloneHum.Parent = player.Character
        humanoid:Destroy()
        cloneHum.Name = "Humanoid"
        
        -- Method 2: Prevent joint breaks
        player.Character.Humanoid.BreakJointsOnDeath = false
        
        -- Method 3: Hook health
        local healthHook
        healthHook = hookmetamethod(game, "__index", function(self, key)
            if self == player.Character.Humanoid and key == "Health" then
                return 100
            end
            return healthHook(self, key)
        end)
        
        setStatus("God Mode attempted (may not work in all games)")
    end
end
function toggleAutoFarm()
    local autoFarmEnabled = not (getgenv().AutoFarmConnection ~= nil)
    
    if autoFarmEnabled then
        -- Common resource names
        local resourceNames = {
            "Coin", "Gem", "Diamond", "Cash", "Money", "Gold", "Silver", "Bronze",
            "Chest", "Crate", "Box", "Ore", "Resource", "Collectible", "Pickup",
            "XP", "Exp", "Experience", "Points", "Token"
        }
        
        getgenv().AutoFarmConnection = RunService.Heartbeat:Connect(function()
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            
            local rootPart = player.Character.HumanoidRootPart
            local closestResource = nil
            local shortestDistance = 50 -- Max distance
            
            -- First search workspace
            for _, child in ipairs(workspace:GetDescendants()) do
                if child:IsA("BasePart") or child:IsA("Model") then
                    local isResource = false
                    
                    -- Name check
                    for _, resourceName in ipairs(resourceNames) do
                        if child.Name:lower():find(resourceName:lower()) or 
                           (child.Parent and child.Parent.Name:lower():find(resourceName:lower())) then
                            isResource = true
                            break
                        end
                    end
                    
                    -- Physical property check (shine, rotation, etc.)
                    if not isResource and child:IsA("BasePart") then
                        if child:FindFirstChildOfClass("ParticleEmitter") or
                           child:FindFirstChildOfClass("PointLight") or
                           child:FindFirstChildOfClass("Sparkles") then
                            isResource = true
                        end
                        
                        -- Also check by color
                        if not isResource and (
                            child.BrickColor == BrickColor.new("Bright yellow") or -- Gold/Money color
                            child.BrickColor == BrickColor.new("Bright blue") or   -- Gem color
                            child.BrickColor == BrickColor.new("New Yeller")       -- Money color
                        ) then
                            isResource = true
                        end
                    end
                    
                    if isResource then
                        local targetPosition = child:IsA("Model") and child:GetModelCFrame().Position or child.Position
                        local distance = (targetPosition - rootPart.Position).Magnitude
                        
                        if distance < shortestDistance then
                            shortestDistance = distance
                            closestResource = child
                        end
                    end
                end
            end
            
            -- If a resource is found, auto collect
            if closestResource then
                local targetPosition = closestResource:IsA("Model") and closestResource:GetModelCFrame().Position or closestResource.Position
                
                -- Move toward resource
                player.Character.Humanoid:MoveTo(targetPosition)
                
                -- If very close, teleport directly onto it for faster collection
                if shortestDistance < 10 then
                    rootPart.CFrame = CFrame.new(targetPosition)
                end
                
                -- Trigger touch interest
                pcall(function()
                    firetouchinterest(rootPart, closestResource, 0)
                    wait(0.1)
                    firetouchinterest(rootPart, closestResource, 1)
                end)
                
                -- Try remote events
                for _, event in pairs(closestResource:GetDescendants()) do
                    if event:IsA("RemoteEvent") and (event.Name:lower():find("collect") or event.Name:lower():find("pickup") or event.Name:lower():find("grab")) then
                        pcall(function()
                            event:FireServer()
                        end)
                    end
                end
            end
        end)
        
        setStatus("Auto farm enabled")
    else
        if getgenv().AutoFarmConnection then
            getgenv().AutoFarmConnection:Disconnect()
            getgenv().AutoFarmConnection = nil
        end
        
        setStatus("Auto farm disabled")
    end
end
function increaseReach()
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        
        if method == "FireServer" and string.find(self.Name:lower(), "hit") or string.find(self.Name:lower(), "damage") then
            -- Check and modify arguments
            for i, v in pairs(args) do
                if typeof(v) == "Vector3" then
                    -- Increase range
                    args[i] = player.Character.HumanoidRootPart.Position + (v - player.Character.HumanoidRootPart.Position).unit * 30
                end
                
                if typeof(v) == "Instance" and v:IsA("BasePart") then
                    -- Find closest player
                    local closestPlayer = nil
                    local shortestDistance = 20 -- Increased range
                    
                    for _, otherPlayer in ipairs(Players:GetPlayers()) do
                        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            local distance = (otherPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                            
                            if distance < shortestDistance then
                                shortestDistance = distance
                                closestPlayer = otherPlayer
                            end
                        end
                    end
                    
                    if closestPlayer then
                        args[i] = closestPlayer.Character.HumanoidRootPart
                    end
                end
            end
            
            return oldNamecall(self, unpack(args))
        end
        
        return oldNamecall(self, ...)
    end)
    
    setStatus("Weapon reach increased (may not work in all games)")
end
function playAnimation(animType)
    if not player.Character or not player.Character:FindFirstChild("Humanoid") then
        setStatus("Cannot play animation: character not found")
        return
    end
    
    local animId = animationIds[animType:lower()]
    if not animId then
        setStatus("Animation not found: " .. animType)
        return
    end
    
    -- Track animations
    if not getgenv().AnimationTracks then
        getgenv().AnimationTracks = {}
    end
    
    -- Stop previous animation
    if getgenv().AnimationTracks[animType] then
        getgenv().AnimationTracks[animType]:Stop()
        getgenv().AnimationTracks[animType] = nil
    end
    
    -- Play the animation
    local anim = Instance.new("Animation")
    anim.AnimationId = animId
    
    local animTrack = player.Character.Humanoid:LoadAnimation(anim)
    animTrack:Play()
    
    -- Save animation
    getgenv().AnimationTracks[animType] = animTrack
    
    setStatus(animType .. " animation playing")
end
function playDanceAnimation()
    local animations = {
        "rbxassetid://507771019", -- Shuffle
        "rbxassetid://429703734", -- Moonwalk
        "rbxassetid://35654637",  -- Thriller
        "rbxassetid://129423030", -- Breakdance
        "rbxassetid://3189773368" -- Floss
    }
    
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local animationIndex = math.random(1, #animations)
        local anim = Instance.new("Animation")
        anim.AnimationId = animations[animationIndex]
        
        local animTrack = player.Character.Humanoid:LoadAnimation(anim)
        animTrack:Play()
        
        setStatus("Dance animation playing")
    end
end
function fakeChatMessage(targetName, message)
    local targetPlayer = getPlayerFromName(targetName)
    
    if not targetPlayer then
        setStatus("Player not found")
        return
    end
    
    -- Find chat GUI
    local chatGui = nil
    
    for _, gui in ipairs(player.PlayerGui:GetChildren()) do
        if gui.Name:lower():find("chat") then
            chatGui = gui
            break
        end
    end
    
    if not chatGui then
        setStatus("Chat interface not found")
        return
    end
    
    -- Create fake message
    local fakeMessageFrame = Instance.new("Frame")
    fakeMessageFrame.Size = UDim2.new(1, 0, 0, 20)
    fakeMessageFrame.BackgroundTransparency = 1
    
    local fakeMessageText = Instance.new("TextLabel")
    fakeMessageText.Size = UDim2.new(1, 0, 1, 0)
    fakeMessageText.BackgroundTransparency = 1
    fakeMessageText.Font = Enum.Font.SourceSans
    fakeMessageText.TextSize = 16
    fakeMessageText.TextXAlignment = Enum.TextXAlignment.Left
    fakeMessageText.TextColor3 = Color3.fromRGB(255, 255, 255)
    
    -- Set team colors
    if targetPlayer.Team then
        fakeMessageText.TextColor3 = targetPlayer.TeamColor.Color
    end
    
    fakeMessageText.Text = targetPlayer.Name .. ": " .. message
    fakeMessageText.Parent = fakeMessageFrame
    
    -- Add message to chat history
    for _, child in ipairs(chatGui:GetDescendants()) do
        if child:IsA("ScrollingFrame") and child.Name:lower():find("chat") or child.Name:lower():find("message") then
            fakeMessageFrame.Parent = child
            break
        end
    end
    
    setStatus("Fake message sent")
    
    -- Remove message after a while
    delay(10, function()
        fakeMessageFrame:Destroy()
    end)
end
function makeGiantSize()
    if player.Character then
        for _, part in pairs(player.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Size = part.Size * 3
            end
        end
        
        if player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.HipHeight = player.Character.Humanoid.HipHeight * 3
        end
        
        setStatus("Character size increased")
    end
end
function makeTinySize()
    if player.Character then
        for _, part in pairs(player.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Size = part.Size * 0.5
            end
        end
        
        if player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.HipHeight = player.Character.Humanoid.HipHeight * 0.5
        end
        
        setStatus("Character size decreased")
    end
end
function createFloatingParts()
    local parts = {}
    local colors = {
        Color3.fromRGB(255, 0, 0),
        Color3.fromRGB(0, 255, 0),
        Color3.fromRGB(0, 0, 255),
        Color3.fromRGB(255, 255, 0),
        Color3.fromRGB(0, 255, 255),
        Color3.fromRGB(255, 0, 255)
    }
    
    -- Create 20 parts
    for i = 1, 20 do
        local part = Instance.new("Part")
        part.Size = Vector3.new(1, 1, 1)
        part.Anchored = true
        part.CanCollide = false
        part.BrickColor = BrickColor.new(colors[math.random(1, #colors)])
        part.Material = Enum.Material.Neon
        part.Shape = Enum.PartType.Ball
        part.Parent = workspace
        
        table.insert(parts, part)
    end
    
    -- Orbit parts around player
    local angle = 0
    local radius = 5
    local angleStep = math.pi * 2 / #parts
    local floatingLoop
    
    floatingLoop = RunService.Heartbeat:Connect(function()
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            -- Clean up if character disappears
            for _, part in ipairs(parts) do
                part:Destroy()
            end
            floatingLoop:Disconnect()
            return
        end
        
        angle = angle + 0.03
        
        for i, part in ipairs(parts) do
            local x = math.cos(angle + i * angleStep) * radius
            local y = math.sin(angle * 0.5) * 2 + 4
            local z = math.sin(angle + i * angleStep) * radius
            
            part.Position = player.Character.HumanoidRootPart.Position + Vector3.new(x, y, z)
        end
    end)
    
    -- Clean up after 30 seconds
    delay(30, function()
        floatingLoop:Disconnect()
        for _, part in ipairs(parts) do
            part:Destroy()
        end
    end)
    
    setStatus("Floating parts created (30 seconds)")
end
function spinCharacter()
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local spinSpeed = 10 -- Spin speed
        local isSpinning = true
        
        local spinLoop
        spinLoop = RunService.Heartbeat:Connect(function()
            if not isSpinning or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                spinLoop:Disconnect()
                return
            end
            
            player.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
        end)
        
        -- Stop spinning after 10 seconds
        delay(10, function()
            isSpinning = false
            setStatus("Spinning stopped")
        end)
        
        setStatus("Character spinning (10 seconds)")
    end
end
function loadUltimateFling()
    setStatus("Loading Ultimate Fling...")
    
    -- Load the script and modify it to add KILASIK credit and close button
    local ultimateFlingCode = game:HttpGet("https://raw.githubusercontent.com/K1LAS1K/Ultimate-Fling-GUI/main/flingscript.lua")
    
    -- Add KILASIK credit
    ultimateFlingCode = ultimateFlingCode:gsub("Credit to X", "Credit to KILASIK")
    
    -- Add close button
    ultimateFlingCode = ultimateFlingCode .. [[
    -- Add close button
    pcall(function()
        wait(1) -- Wait for GUI to load
        
        local function addCloseButton()
            for _, gui in pairs(game:GetService("CoreGui"):GetChildren()) do
                if gui:IsA("ScreenGui") and not gui:FindFirstChild("KilasikCloseButton") then
                    -- Check if this is our GUI
                    if gui:FindFirstChild("Frame") and gui:FindFirstChild("Frame"):FindFirstChild("TextLabel") then
                        local mainFrame = gui:FindFirstChild("Frame")
                        
                        -- Create close button
                        local closeButton = Instance.new("TextButton")
                        closeButton.Name = "KilasikCloseButton"
                        closeButton.Size = UDim2.new(0, 25, 0, 25)
                        closeButton.Position = UDim2.new(1, -30, 0, 5)
                        closeButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                        closeButton.Text = "X"
                        closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                        closeButton.Font = Enum.Font.GothamBold
                        closeButton.TextSize = 14
                        closeButton.BorderSizePixel = 0
                        closeButton.ZIndex = 10
                        closeButton.Parent = mainFrame
                        
                        -- Create corner
                        local corner = Instance.new("UICorner")
                        corner.CornerRadius = UDim.new(0, 4)
                        corner.Parent = closeButton
                        
                        -- Add click function
                        closeButton.MouseButton1Click:Connect(function()
                            gui:Destroy()
                        end)
                        
                        -- Update credit text
                        for _, element in pairs(mainFrame:GetDescendants()) do
                            if element:IsA("TextLabel") and element.Text:find("Credit") then
                                element.Text = "Credit: KILASIK"
                            end
                        end
                    end
                end
            end
        end
        
        -- Try to add close button multiple times to ensure it works
        for i = 1, 5 do
            wait(i)
            addCloseButton()
        end
    end)
    ]]
    
    -- Execute modified script
    loadstring(ultimateFlingCode)()
end
function loadTouchFling()
    setStatus("Loading Touch Fling...")
    
    -- Load script and modify
    local touchFlingCode = game:HttpGet('https://raw.githubusercontent.com/0Ben1/fe/main/obf_rf6iQURzu1fqrytcnLBAvW34C9N55kS9g9G3CKz086rC47M6632sEd4ZZYB0AYgV.lua.txt')
    
    -- Modify credit
    touchFlingCode = touchFlingCode:gsub("Credit to X", "Credit to KILASIK")
    
    -- Add close button
    touchFlingCode = touchFlingCode .. [[
    -- Add close button
    pcall(function()
        wait(1) -- Wait for GUI to load
        
        local function addCloseButton()
            for _, gui in pairs(game:GetService("CoreGui"):GetChildren()) do
                if gui:IsA("ScreenGui") and not gui:FindFirstChild("KilasikCloseButton") then
                    -- Check if this is our GUI by looking for specific elements
                    for _, frame in pairs(gui:GetChildren()) do
                        if frame:IsA("Frame") and frame:FindFirstChild("TextButton") then
                            -- Create close button
                            local closeButton = Instance.new("TextButton")
                            closeButton.Name = "KilasikCloseButton"
                            closeButton.Size = UDim2.new(0, 25, 0, 25)
                            closeButton.Position = UDim2.new(1, -30, 0, 5)
                            closeButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                            closeButton.Text = "X"
                            closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                            closeButton.Font = Enum.Font.GothamBold
                            closeButton.TextSize = 14
                            closeButton.BorderSizePixel = 0
                            closeButton.ZIndex = 10
                            closeButton.Parent = frame
                            
                            -- Create corner
                            local corner = Instance.new("UICorner")
                            corner.CornerRadius = UDim.new(0, 4)
                            corner.Parent = closeButton
                            
                            -- Add click function
                            closeButton.MouseButton1Click:Connect(function()
                                gui:Destroy()
                            end)
                            
                            -- Update credit text if found
                            for _, element in pairs(frame:GetDescendants()) do
                                if element:IsA("TextLabel") and element.Text:find("Credit") then
                                    element.Text = "Credit: KILASIK"
                                end
                            end
                        end
                    end
                end
            end
        end
        
        -- Try to add close button multiple times to ensure it works
        for i = 1, 5 do
            wait(i)
            addCloseButton()
        end
    end)
    ]]
    
    -- Execute modified script
    loadstring(touchFlingCode)()
end
function spectatePlayer(targetName)
    -- If name provided directly
    if targetName and targetName ~= "" then
        local targetPlayer = getPlayerFromName(targetName)
        
        if targetPlayer and targetPlayer.Character then
            workspace.CurrentCamera.CameraSubject = targetPlayer.Character.Humanoid
            setStatus("Spectating " .. targetPlayer.Name)
        else
            setStatus("Player not found")
        end
        return
    end
    
    -- If no name provided, show player selector
    createPlayerSelector("Select Player to Spectate", function(targetPlayer)
        if targetPlayer and targetPlayer.Character then
            workspace.CurrentCamera.CameraSubject = targetPlayer.Character.Humanoid
            setStatus("Spectating " .. targetPlayer.Name)
        else
            setStatus("Player not found")
        end
    end)
end
function unspectatePlayer()
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        workspace.CurrentCamera.CameraSubject = player.Character.Humanoid
        setStatus("Spectating stopped")
    end
end
function goToPlayer(targetName)
    teleportToPlayer(targetName) -- Use same function
end
function bringPlayer(targetName)
    -- If name provided directly
    if targetName and targetName ~= "" then
        local targetPlayer = getPlayerFromName(targetName)
        
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and
           player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            
            -- Note: This function won't work in most games - cross-game protection
            
            -- Method 1: Try to change position
            targetPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 3)
            
            -- Method 2: Try network ownership
            if targetPlayer.Character:FindFirstChildOfClass("Tool") then
                local tool = targetPlayer.Character:FindFirstChildOfClass("Tool")
                local handle = tool:FindFirstChild("Handle")
                
                if handle then
                    handle.CFrame = player.Character.HumanoidRootPart.CFrame
                end
            end
            
            setStatus("Attempted to bring player (may not work in most games)")
        else
            setStatus("Player not found or unreachable")
        end
        return
    end
    
    -- If no name provided, show player selector
    createPlayerSelector("Select Player to Bring", function(targetPlayer)
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and
           player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            
            -- Method 1: Try to change position
            targetPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 3)
            
            -- Method 2: Try network ownership
            if targetPlayer.Character:FindFirstChildOfClass("Tool") then
                local tool = targetPlayer.Character:FindFirstChildOfClass("Tool")
                local handle = tool:FindFirstChild("Handle")
                
                if handle then
                    handle.CFrame = player.Character.HumanoidRootPart.CFrame
                end
            end
            
            setStatus("Attempted to bring player (may not work in most games)")
        else
            setStatus("Player not found or unreachable")
        end
    end)
end
function flingPlayer(targetName)
    -- If name provided directly
    if targetName and targetName ~= "" then
        local targetPlayer = getPlayerFromName(targetName)
        
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and
           player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            
            -- Note: This function won't work in most games - cross-game protection
            
            -- Save position
            local oldPos = player.Character.HumanoidRootPart.CFrame
            
            -- Increase character speed
            player.Character.Humanoid.WalkSpeed = 100
            
            -- Run toward target player
            player.Character.Humanoid:MoveTo(targetPlayer.Character.HumanoidRootPart.Position)
            
            -- Increase impact
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.P = math.huge
            bodyVelocity.Parent = player.Character.HumanoidRootPart
            
            -- Wait and increase impact right after collision
            delay(0.5, function()
                bodyVelocity.Velocity = player.Character.HumanoidRootPart.CFrame.LookVector * 500
                bodyVelocity.Parent = targetPlayer.Character.HumanoidRootPart
                
                -- Clean up after 1 second and return to original position
                delay(1, function()
                    bodyVelocity:Destroy()
                    player.Character.HumanoidRootPart.CFrame = oldPos
                    player.Character.Humanoid.WalkSpeed = 16
                end)
            end)
            
            setStatus("Attempted to fling player (may not work in most games)")
        else
            setStatus("Player not found or unflingable")
        end
        return
    end
    
    -- If no name provided, show player selector
    createPlayerSelector("Select Player to Fling", function(targetPlayer)
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and
           player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            
            -- Save position
            local oldPos = player.Character.HumanoidRootPart.CFrame
            
            -- Increase character speed
            player.Character.Humanoid.WalkSpeed = 100
            
            -- Run toward target player
            player.Character.Humanoid:MoveTo(targetPlayer.Character.HumanoidRootPart.Position)
            
            -- Increase impact
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.P = math.huge
            bodyVelocity.Parent = player.Character.HumanoidRootPart
            
            -- Wait and increase impact right after collision
            delay(0.5, function()
                bodyVelocity.Velocity = player.Character.HumanoidRootPart.CFrame.LookVector * 500
                bodyVelocity.Parent = targetPlayer.Character.HumanoidRootPart
                
                -- Clean up after 1 second and return to original position
                delay(1, function()
                    bodyVelocity:Destroy()
                    player.Character.HumanoidRootPart.CFrame = oldPos
                    player.Character.Humanoid.WalkSpeed = 16
                end)
            end)
            
            setStatus("Attempted to fling player (may not work in most games)")
        else
            setStatus("Player not found or unflingable")
        end
    end)
end
function copyPosition()
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local position = player.Character.HumanoidRootPart.Position
        local posText = "Vector3.new(" .. tostring(position.X) .. ", " .. tostring(position.Y) .. ", " .. tostring(position.Z) .. ")"
        
        setclipboard(posText)
        setStatus("Position copied: " .. posText)
    else
        setStatus("Position copy failed")
    end
end
function giveBTools()
    local toolNames = {"Move", "Clone", "Delete", "Grab"}
    
    for _, toolName in ipairs(toolNames) do
        local tool = Instance.new("HopperBin")
        tool.Name = toolName
        tool.BinType = Enum.BinType[toolName]
        tool.Parent = player.Backpack
    end
    
    setStatus("Building tools given")
end
function applyForceField()
    if player.Character then
        local forceField = Instance.new("ForceField")
        forceField.Parent = player.Character
        
        setStatus("Force field applied")
    end
end
function doHighJump()
    if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart") then
        local jumpForce = 100
        
        -- Check if on ground
        local isOnGround = player.Character.Humanoid:GetState() == Enum.HumanoidStateType.Running or
                           player.Character.Humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics
        
        if isOnGround then
            -- Apply upward force with BodyVelocity
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Velocity = Vector3.new(0, jumpForce, 0)
            bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
            bodyVelocity.Parent = player.Character.HumanoidRootPart
            
            -- Clean up after 0.2 seconds
            delay(0.2, function()
                bodyVelocity:Destroy()
            end)
            
            setStatus("High jump executed")
        else
            setStatus("You must be on the ground to jump")
        end
    end
end
function toggleSwimMode()
    local swimModeEnabled = not (getgenv().SwimModeConnection ~= nil)
    
    if swimModeEnabled then
        getgenv().SwimModeConnection = RunService.Heartbeat:Connect(function()
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                -- Set humanoid state to swimming
                player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
                
                -- 3D movement with WASD
                local moveDirection = player.Character.Humanoid.MoveDirection
                
                if moveDirection.Magnitude > 0 then
                    player.Character.HumanoidRootPart.Velocity = camera.CFrame:VectorToWorldSpace(Vector3.new(
                        moveDirection.X * 30,
                        moveDirection.Y * 30,
                        moveDirection.Z * 30
                    ))
                else
                    player.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                end
            end
        end)
        
        setStatus("Swim mode enabled")
    else
        if getgenv().SwimModeConnection then
            getgenv().SwimModeConnection:Disconnect()
            getgenv().SwimModeConnection = nil
        end
        
        -- Return character to normal state
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
        
        setStatus("Swim mode disabled")
    end
end
function makeRainbowCharacter()
    if player.Character then
        local rainbowSpeed = 2
        local hue = 0
        
        local rainbowLoop
        rainbowLoop = RunService.Heartbeat:Connect(function()
            if not player.Character then
                rainbowLoop:Disconnect()
                return
            end
            
            hue = (hue + rainbowSpeed) % 360
            local color = Color3.fromHSV(hue/360, 1, 1)
            
            for _, part in ipairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.Color = color
                end
            end
        end)
        
        -- Disable after 30 seconds
        delay(30, function()
            rainbowLoop:Disconnect()
            setStatus("Rainbow effect ended")
        end)
        
        setStatus("Rainbow character effect applied (30 seconds)")
    end
end
function clearMap()
    -- Define what to protect for player and game mechanics safety
    local protectedNames = {
        "Workspace", "Camera", "Terrain", "SpawnLocation", "Players", "Script", "LocalScript", "StarterPack",
        "StarterGui", "StarterPlayer", "TouchTransmitter"
    }
    
    local function isProtected(obj)
        for _, name in ipairs(protectedNames) do
            if obj.Name:find(name) or obj:IsA(name) or obj:IsDescendantOf(Players) then
                return true
            end
        end
        return false
    end
    
    local removedCount = 0
    local maxRemove = 100 -- Safety limit to prevent crashing
    
    for _, obj in ipairs(workspace:GetDescendants()) do
        if not isProtected(obj) and obj:IsA("BasePart") and obj.Anchored then
            obj.Transparency = 1
            obj.CanCollide = false
            removedCount = removedCount + 1
            
            if removedCount >= maxRemove then
                break
            end
        end
    end
    
    setStatus("Hid " .. removedCount .. " map objects (made transparent)")
end
function setLowGraphics()
    -- Lower graphics quality
    settings().Rendering.QualityLevel = 1
    
    -- Disable shadows and effects
    game:GetService("Lighting").GlobalShadows = false
